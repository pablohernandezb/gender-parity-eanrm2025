# Aplica la misma lógica que para Concejal(a) Nominal
Paridad_Indigena = {
indigenous_candidates <- filter(cur_data(), election_type_id == ELECTION_ID_INDIGENOUS_COUNCIL, list_order %in% c(1, 2))
principal_candidates <- filter(indigenous_candidates, list_order == 1)
total_principals <- nrow(principal_candidates)
Paridad_Indigena_Principal <- if (total_principals == 0) {
NA_real_
} else {
(sum(principal_candidates$gender == "F") / total_principals) * 100
}
suplente_candidates <- filter(indigenous_candidates, list_order == 2)
total_suplentes <- nrow(suplente_candidates)
Paridad_Indigena_Suplente <- if (total_suplentes == 0) {
NA_real_
} else {
(sum(suplente_candidates$gender == "F") / total_suplentes) * 100
}
if (is.na(Paridad_Indigena_Principal) && is.na(Paridad_Indigena_Suplente)) {
NA_real_
} else {
mean(c(Paridad_Indigena_Principal, Paridad_Indigena_Suplente), na.rm = TRUE)
}
},
# --- D. Paridad para Concejal(a) Lista (ID 16) ---
Paridad_Lista = {
list_candidates <- filter(cur_data(), election_type_id == ELECTION_ID_LIST_COUNCIL)
total_list_candidates <- nrow(list_candidates)
if (total_list_candidates == 0) {
NA_real_
} else {
# Componente 1: Porcentaje de Mujeres en la Lista
perc_women_list <- (sum(list_candidates$gender == "F") / total_list_candidates) * 100
# Componente 2: Paridad de Posición Promedio Normalizada
# Un valor más alto indica que las mujeres están en mejores posiciones promedio
avg_pos_women <- mean(filter(list_candidates, gender == "F")$list_order, na.rm = TRUE)
avg_pos_men <- mean(filter(list_candidates, gender == "M")$list_order, na.rm = TRUE)
# Manejo de casos sin datos para un género
if (is.nan(avg_pos_women)) avg_pos_women <- NA_real_
if (is.nan(avg_pos_men)) avg_pos_men <- NA_real_
normalized_pos_parity <- NA_real_ # Valor predeterminado
if (!is.na(avg_pos_women) && !is.na(avg_pos_men)) {
diff_avg_pos <- avg_pos_men - avg_pos_women # Diferencia: Hombres - Mujeres (positivo si hombres están más arriba)
max_list_order_municipality <- max(list_candidates$list_order, na.rm = TRUE)
if (max_list_order_municipality <= 1 || is.nan(diff_avg_pos)) {
normalized_pos_parity <- 100 # Si solo hay un candidato o lista de tamaño 1, se considera paridad perfecta de posición.
} else {
# Escala la diferencia para que 0 sea la peor paridad de posición para las mujeres y 100 la mejor.
# Rango posible de diff_avg_pos: de (1 - max_order) a (max_order - 1)
min_possible_diff = 1 - max_list_order_municipality
max_possible_diff = max_list_order_municipality - 1
if (max_possible_diff == min_possible_diff) { # Evita división por cero si max_order es 1
normalized_pos_parity <- 100
} else {
normalized_pos_parity <- ((diff_avg_pos - min_possible_diff) / (max_possible_diff - min_possible_diff)) * 100
}
}
} else if (is.na(avg_pos_women) || is.na(avg_pos_men)) {
# Si solo hay un género presente, la paridad de posición para ese género es "perfecta"
normalized_pos_parity <- 100
}
# Componente 3: Porcentaje de Mujeres en la Primera Mitad de la Lista
first_half_max_order <- ceiling(max(list_candidates$list_order, na.rm = TRUE) / 2)
first_half_candidates <- filter(list_candidates, list_order <= first_half_max_order)
total_in_first_half <- nrow(first_half_candidates)
perc_women_first_half <- if (total_in_first_half == 0) {
NA_real_
} else {
(sum(first_half_candidates$gender == "F") / total_in_first_half) * 100
}
# Combinar los tres componentes de la Paridad de Lista (promedio simple)
mean(c(perc_women_list, normalized_pos_parity, perc_women_first_half), na.rm = TRUE)
}
},
.groups = 'drop' # Asegura que el resultado final no esté agrupado
)
# --- 2. Definir IDs de Tipos de Elección ---
ELECTION_ID_MAYOR <- 3
ELECTION_ID_NOMINAL_COUNCIL <- 15
ELECTION_ID_INDIGENOUS_COUNCIL <- 17
ELECTION_ID_LIST_COUNCIL <- 16
# --- 3. Calcular Métricas de Paridad por Municipio ---
# Agrupar por estado y municipio para realizar los cálculos para cada uno
municipal_parity_metrics <- em2025 %>%
group_by(cod_state, cod_municipality, state_description, municipality_description) %>%
summarise(
# --- A. Paridad para Alcalde(sa) (ID 3) ---
Paridad_Alcalde = {
mayor_candidates <- filter(cur_data(), election_type_id == ELECTION_ID_MAYOR)
total_candidates <- nrow(mayor_candidates)
if (total_candidates == 0) {
NA_real_ # Si no hay candidatos, la paridad es NA
} else {
(sum(mayor_candidates$gender == "F") / total_candidates) * 100
}
},
# --- B. Paridad para Concejal(a) Nominal (ID 15) ---
# Distingue Principal (list_order=1) y Suplente (list_order=2)
Paridad_Nominal = {
nominal_candidates <- filter(cur_data(), election_type_id == ELECTION_ID_NOMINAL_COUNCIL, list_order %in% c(1, 2))
# Calcular Paridad para Principales
principal_candidates <- filter(nominal_candidates, list_order == 1)
total_principals <- nrow(principal_candidates)
Paridad_Nominal_Principal <- if (total_principals == 0) {
NA_real_
} else {
(sum(principal_candidates$gender == "F") / total_principals) * 100
}
# Calcular Paridad para Suplentes
suplente_candidates <- filter(nominal_candidates, list_order == 2)
total_suplentes <- nrow(suplente_candidates)
Paridad_Nominal_Suplente <- if (total_suplentes == 0) {
NA_real_
} else {
(sum(suplente_candidates$gender == "F") / total_suplentes) * 100
}
# Combinar Paridad de Principales y Suplentes (promedio)
if (is.na(Paridad_Nominal_Principal) && is.na(Paridad_Nominal_Suplente)) {
NA_real_
} else {
mean(c(Paridad_Nominal_Principal, Paridad_Nominal_Suplente), na.rm = TRUE)
}
},
# --- C. Paridad para Concejal(a) Indígena (ID 17) ---
# Aplica la misma lógica que para Concejal(a) Nominal
Paridad_Indigena = {
indigenous_candidates <- filter(cur_data(), election_type_id == ELECTION_ID_INDIGENOUS_COUNCIL, list_order %in% c(1, 2))
principal_candidates <- filter(indigenous_candidates, list_order == 1)
total_principals <- nrow(principal_candidates)
Paridad_Indigena_Principal <- if (total_principals == 0) {
NA_real_
} else {
(sum(principal_candidates$gender == "F") / total_principals) * 100
}
suplente_candidates <- filter(indigenous_candidates, list_order == 2)
total_suplentes <- nrow(suplente_candidates)
Paridad_Indigena_Suplente <- if (total_suplentes == 0) {
NA_real_
} else {
(sum(suplente_candidates$gender == "F") / total_suplentes) * 100
}
if (is.na(Paridad_Indigena_Principal) && is.na(Paridad_Indigena_Suplente)) {
NA_real_
} else {
mean(c(Paridad_Indigena_Principal, Paridad_Indigena_Suplente), na.rm = TRUE)
}
},
# --- D. Paridad para Concejal(a) Lista (ID 16) ---
Paridad_Lista = {
list_candidates <- filter(cur_data(), election_type_id == ELECTION_ID_LIST_COUNCIL)
total_list_candidates <- nrow(list_candidates)
if (total_list_candidates == 0) {
NA_real_
} else {
# Componente 1: Porcentaje de Mujeres en la Lista
perc_women_list <- (sum(list_candidates$gender == "F") / total_list_candidates) * 100
# Componente 2: Paridad de Posición Promedio Normalizada
# Un valor más alto indica que las mujeres están en mejores posiciones promedio
avg_pos_women <- mean(filter(list_candidates, gender == "F")$list_order, na.rm = TRUE)
avg_pos_men <- mean(filter(list_candidates, gender == "M")$list_order, na.rm = TRUE)
# Manejo de casos sin datos para un género
if (is.nan(avg_pos_women)) avg_pos_women <- NA_real_
if (is.nan(avg_pos_men)) avg_pos_men <- NA_real_
normalized_pos_parity <- NA_real_ # Valor predeterminado
if (!is.na(avg_pos_women) && !is.na(avg_pos_men)) {
diff_avg_pos <- avg_pos_men - avg_pos_women # Diferencia: Hombres - Mujeres (positivo si hombres están más arriba)
max_list_order_municipality <- max(list_candidates$list_order, na.rm = TRUE)
if (max_list_order_municipality <= 1 || is.nan(diff_avg_pos)) {
normalized_pos_parity <- 100 # Si solo hay un candidato o lista de tamaño 1, se considera paridad perfecta de posición.
} else {
# Escala la diferencia para que 0 sea la peor paridad de posición para las mujeres y 100 la mejor.
# Rango posible de diff_avg_pos: de (1 - max_order) a (max_order - 1)
min_possible_diff = 1 - max_list_order_municipality
max_possible_diff = max_list_order_municipality - 1
if (max_possible_diff == min_possible_diff) { # Evita división por cero si max_order es 1
normalized_pos_parity <- 100
} else {
normalized_pos_parity <- ((diff_avg_pos - min_possible_diff) / (max_possible_diff - min_possible_diff)) * 100
}
}
} else if (is.na(avg_pos_women) || is.na(avg_pos_men)) {
# Si solo hay un género presente, la paridad de posición para ese género es "perfecta"
normalized_pos_parity <- 100
}
# Componente 3: Porcentaje de Mujeres en la Primera Mitad de la Lista
first_half_max_order <- ceiling(max(list_candidates$list_order, na.rm = TRUE) / 2)
first_half_candidates <- filter(list_candidates, list_order <= first_half_max_order)
total_in_first_half <- nrow(first_half_candidates)
perc_women_first_half <- if (total_in_first_half == 0) {
NA_real_
} else {
(sum(first_half_candidates$gender == "F") / total_in_first_half) * 100
}
# Combinar los tres componentes de la Paridad de Lista (promedio simple)
mean(c(perc_women_list, normalized_pos_parity, perc_women_first_half), na.rm = TRUE)
}
},
.groups = 'drop' # Asegura que el resultado final no esté agrupado
)
# --- 2. Definir IDs de Tipos de Elección ---
ELECTION_ID_MAYOR <- 3
ELECTION_ID_NOMINAL_COUNCIL <- 15
ELECTION_ID_INDIGENOUS_COUNCIL <- 17
ELECTION_ID_LIST_COUNCIL <- 16
# --- FUNCIONES AUXILIARES PARA CADA CÁLCULO DE PARIDAD ---
# Función para calcular la paridad de Alcalde(sa)
calculate_parity_mayor <- function(data_group) {
mayor_candidates <- filter(data_group, election_type_id == ELECTION_ID_MAYOR)
total_candidates <- nrow(mayor_candidates)
if (total_candidates == 0) {
NA_real_
} else {
(sum(mayor_candidates$gender == "F") / total_candidates) * 100
}
}
# Función para calcular la paridad de Concejal(a) Nominal o Indígena
calculate_parity_nominal_indigenous <- function(data_group, election_id) {
candidates <- filter(data_group, election_type_id == election_id, list_order %in% c(1, 2))
# Calcular Paridad para Principales
principal_candidates <- filter(candidates, list_order == 1)
total_principals <- nrow(principal_candidates)
Paridad_Principal <- if (total_principals == 0) NA_real_ else (sum(principal_candidates$gender == "F") / total_principals) * 100
# Calcular Paridad para Suplentes
suplente_candidates <- filter(candidates, list_order == 2)
total_suplentes <- nrow(suplente_candidates)
Paridad_Suplente <- if (total_suplentes == 0) NA_real_ else (sum(suplente_candidates$gender == "F") / total_suplentes) * 100
# Combinar Paridad de Principales y Suplentes (promedio)
if (is.na(Paridad_Principal) && is.na(Paridad_Suplente)) {
NA_real_
} else {
mean(c(Paridad_Principal, Paridad_Suplente), na.rm = TRUE)
}
}
# Función para calcular la paridad de Concejal(a) Lista
calculate_parity_list <- function(data_group) {
list_candidates <- filter(data_group, election_type_id == ELECTION_ID_LIST_COUNCIL)
total_list_candidates <- nrow(list_candidates)
if (total_list_candidates == 0) {
NA_real_
} else {
# Componente 1: Porcentaje de Mujeres en la Lista
perc_women_list <- (sum(list_candidates$gender == "F") / total_list_candidates) * 100
# Componente 2: Paridad de Posición Promedio Normalizada
avg_pos_women <- mean(filter(list_candidates, gender == "F")$list_order, na.rm = TRUE)
avg_pos_men <- mean(filter(list_candidates, gender == "M")$list_order, na.rm = TRUE)
if (is.nan(avg_pos_women)) avg_pos_women <- NA_real_
if (is.nan(avg_pos_men)) avg_pos_men <- NA_real_
normalized_pos_parity <- NA_real_
if (!is.na(avg_pos_women) && !is.na(avg_pos_men)) {
diff_avg_pos <- avg_pos_men - avg_pos_women
max_list_order_municipality <- max(list_candidates$list_order, na.rm = TRUE)
if (max_list_order_municipality <= 1 || is.nan(diff_avg_pos)) {
normalized_pos_parity <- 100
} else {
min_possible_diff = 1 - max_list_order_municipality
max_possible_diff = max_list_order_municipality - 1
if (max_possible_diff == min_possible_diff) {
normalized_pos_parity <- 100
} else {
normalized_pos_parity <- ((diff_avg_pos - min_possible_diff) / (max_possible_diff - min_possible_diff)) * 100
}
}
} else if (is.na(avg_pos_women) || is.na(avg_pos_men)) {
normalized_pos_parity <- 100
}
# Componente 3: Porcentaje de Mujeres en la Primera Mitad de la Lista
first_half_max_order <- ceiling(max(list_candidates$list_order, na.rm = TRUE) / 2)
first_half_candidates <- filter(list_candidates, list_order <= first_half_max_order)
total_in_first_half <- nrow(first_half_candidates)
perc_women_first_half <- if (total_in_first_half == 0) NA_real_ else (sum(first_half_candidates$gender == "F") / total_in_first_half) * 100
mean(c(perc_women_list, normalized_pos_parity, perc_women_first_half), na.rm = TRUE)
}
}
# --- 3. Calcular Métricas de Paridad por Municipio (utilizando las funciones auxiliares) ---
municipal_parity_metrics <- em2025 %>%
group_by(cod_state, cod_municipality, state_description, municipality_description) %>%
summarise(
Paridad_Alcalde = calculate_parity_mayor(cur_data()),
Paridad_Nominal = calculate_parity_nominal_indigenous(cur_data(), ELECTION_ID_NOMINAL_COUNCIL),
Paridad_Indigena = calculate_parity_nominal_indigenous(cur_data(), ELECTION_ID_INDIGENOUS_COUNCIL),
Paridad_Lista = calculate_parity_list(cur_data()),
.groups = 'drop'
)
# --- FUNCIONES AUXILIARES PARA CADA CÁLCULO DE PARIDAD ---
# (Estas funciones son las mismas que en la respuesta anterior, las incluimos por completitud)
# Función para calcular la paridad de Alcalde(sa)
calculate_parity_mayor <- function(data_group) {
mayor_candidates <- filter(data_group, election_type_id == ELECTION_ID_MAYOR)
total_candidates <- nrow(mayor_candidates)
if (total_candidates == 0) {
NA_real_
} else {
(sum(mayor_candidates$gender == "F") / total_candidates) * 100
}
}
# Función para calcular la paridad de Concejal(a) Nominal o Indígena
calculate_parity_nominal_indigenous <- function(data_group, election_id) {
candidates <- filter(data_group, election_type_id == election_id, list_order %in% c(1, 2))
principal_candidates <- filter(candidates, list_order == 1)
total_principals <- nrow(principal_candidates)
Paridad_Principal <- if (total_principals == 0) NA_real_ else (sum(principal_candidates$gender == "F") / total_principals) * 100
suplente_candidates <- filter(candidates, list_order == 2)
total_suplentes <- nrow(suplente_candidates)
Paridad_Suplente <- if (total_suplentes == 0) NA_real_ else (sum(suplente_candidates$gender == "F") / total_suplentes) * 100
if (is.na(Paridad_Principal) && is.na(Paridad_Suplente)) {
NA_real_
} else {
mean(c(Paridad_Principal, Paridad_Suplente), na.rm = TRUE)
}
}
# Función para calcular la paridad de Concejal(a) Lista
calculate_parity_list <- function(data_group) {
list_candidates <- filter(data_group, election_type_id == ELECTION_ID_LIST_COUNCIL)
total_list_candidates <- nrow(list_candidates)
if (total_list_candidates == 0) {
NA_real_
} else {
# Componente 1: Porcentaje de Mujeres en la Lista
perc_women_list <- (sum(list_candidates$gender == "F") / total_list_candidates) * 100
# Componente 2: Paridad de Posición Promedio Normalizada
avg_pos_women <- mean(filter(list_candidates, gender == "F")$list_order, na.rm = TRUE)
avg_pos_men <- mean(filter(list_candidates, gender == "M")$list_order, na.rm = TRUE)
if (is.nan(avg_pos_women)) avg_pos_women <- NA_real_
if (is.nan(avg_pos_men)) avg_pos_men <- NA_real_
normalized_pos_parity <- NA_real_
if (!is.na(avg_pos_women) && !is.na(avg_pos_men)) {
diff_avg_pos <- avg_pos_men - avg_pos_women
max_list_order_municipality <- max(list_candidates$list_order, na.rm = TRUE)
if (max_list_order_municipality <= 1 || is.nan(diff_avg_pos)) {
normalized_pos_parity <- 100
} else {
min_possible_diff = 1 - max_list_order_municipality
max_possible_diff = max_list_order_municipality - 1
if (max_possible_diff == min_possible_diff) {
normalized_pos_parity <- 100
} else {
normalized_pos_parity <- ((diff_avg_pos - min_possible_diff) / (max_possible_diff - min_possible_diff)) * 100
}
}
} else if (is.na(avg_pos_women) || is.na(avg_pos_men)) {
normalized_pos_parity <- 100
}
# Componente 3: Porcentaje de Mujeres en la Primera Mitad de la Lista
first_half_max_order <- ceiling(max(list_candidates$list_order, na.rm = TRUE) / 2)
first_half_candidates <- filter(list_candidates, list_order <= first_half_max_order)
total_in_first_half <- nrow(first_half_candidates)
perc_women_first_half <- if (total_in_first_half == 0) NA_real_ else (sum(first_half_candidates$gender == "F") / total_in_first_half) * 100
mean(c(perc_women_list, normalized_pos_parity, perc_women_first_half), na.rm = TRUE)
}
}
# --- 3. Calcular Métricas de Paridad por Municipio (¡USANDO do()!) ---
# Agrupar por estado y municipio
municipal_parity_metrics <- em_data %>%
group_by(cod_state, cod_municipality, state_description, municipality_description) %>%
do({
# 'dot' representa el subconjunto de datos para el grupo actual
group_data <- .
# Llamar a las funciones auxiliares con los datos del grupo actual
Paridad_Alcalde_val <- calculate_parity_mayor(group_data)
Paridad_Nominal_val <- calculate_parity_nominal_indigenous(group_data, ELECTION_ID_NOMINAL_COUNCIL)
Paridad_Indigena_val <- calculate_parity_nominal_indigenous(group_data, ELECTION_ID_INDIGENOUS_COUNCIL)
Paridad_Lista_val <- calculate_parity_list(group_data)
# Devolver una tabla de una sola fila con los resultados para este grupo
tibble(
Paridad_Alcalde = Paridad_Alcalde_val,
Paridad_Nominal = Paridad_Nominal_val,
Paridad_Indigena = Paridad_Indigena_val,
Paridad_Lista = Paridad_Lista_val
)
}) %>%
ungroup() # Desagrupar el resultado final
# --- FUNCIONES AUXILIARES PARA CADA CÁLCULO DE PARIDAD ---
# (Estas funciones son las mismas que en la respuesta anterior, las incluimos por completitud)
# Función para calcular la paridad de Alcalde(sa)
calculate_parity_mayor <- function(data_group) {
mayor_candidates <- filter(data_group, election_type_id == ELECTION_ID_MAYOR)
total_candidates <- nrow(mayor_candidates)
if (total_candidates == 0) {
NA_real_
} else {
(sum(mayor_candidates$gender == "F") / total_candidates) * 100
}
}
# Función para calcular la paridad de Concejal(a) Nominal o Indígena
calculate_parity_nominal_indigenous <- function(data_group, election_id) {
candidates <- filter(data_group, election_type_id == election_id, list_order %in% c(1, 2))
principal_candidates <- filter(candidates, list_order == 1)
total_principals <- nrow(principal_candidates)
Paridad_Principal <- if (total_principals == 0) NA_real_ else (sum(principal_candidates$gender == "F") / total_principals) * 100
suplente_candidates <- filter(candidates, list_order == 2)
total_suplentes <- nrow(suplente_candidates)
Paridad_Suplente <- if (total_suplentes == 0) NA_real_ else (sum(suplente_candidates$gender == "F") / total_suplentes) * 100
if (is.na(Paridad_Principal) && is.na(Paridad_Suplente)) {
NA_real_
} else {
mean(c(Paridad_Principal, Paridad_Suplente), na.rm = TRUE)
}
}
# Función para calcular la paridad de Concejal(a) Lista
calculate_parity_list <- function(data_group) {
list_candidates <- filter(data_group, election_type_id == ELECTION_ID_LIST_COUNCIL)
total_list_candidates <- nrow(list_candidates)
if (total_list_candidates == 0) {
NA_real_
} else {
# Componente 1: Porcentaje de Mujeres en la Lista
perc_women_list <- (sum(list_candidates$gender == "F") / total_list_candidates) * 100
# Componente 2: Paridad de Posición Promedio Normalizada
avg_pos_women <- mean(filter(list_candidates, gender == "F")$list_order, na.rm = TRUE)
avg_pos_men <- mean(filter(list_candidates, gender == "M")$list_order, na.rm = TRUE)
if (is.nan(avg_pos_women)) avg_pos_women <- NA_real_
if (is.nan(avg_pos_men)) avg_pos_men <- NA_real_
normalized_pos_parity <- NA_real_
if (!is.na(avg_pos_women) && !is.na(avg_pos_men)) {
diff_avg_pos <- avg_pos_men - avg_pos_women
max_list_order_municipality <- max(list_candidates$list_order, na.rm = TRUE)
if (max_list_order_municipality <= 1 || is.nan(diff_avg_pos)) {
normalized_pos_parity <- 100
} else {
min_possible_diff = 1 - max_list_order_municipality
max_possible_diff = max_list_order_municipality - 1
if (max_possible_diff == min_possible_diff) {
normalized_pos_parity <- 100
} else {
normalized_pos_parity <- ((diff_avg_pos - min_possible_diff) / (max_possible_diff - min_possible_diff)) * 100
}
}
} else if (is.na(avg_pos_women) || is.na(avg_pos_men)) {
normalized_pos_parity <- 100
}
# Componente 3: Porcentaje de Mujeres en la Primera Mitad de la Lista
first_half_max_order <- ceiling(max(list_candidates$list_order, na.rm = TRUE) / 2)
first_half_candidates <- filter(list_candidates, list_order <= first_half_max_order)
total_in_first_half <- nrow(first_half_candidates)
perc_women_first_half <- if (total_in_first_half == 0) NA_real_ else (sum(first_half_candidates$gender == "F") / total_in_first_half) * 100
mean(c(perc_women_list, normalized_pos_parity, perc_women_first_half), na.rm = TRUE)
}
}
# --- 3. Calcular Métricas de Paridad por Municipio (¡USANDO do()!) ---
# Agrupar por estado y municipio
municipal_parity_metrics <- em2025 %>%
group_by(cod_state, cod_municipality, state_description, municipality_description) %>%
do({
# 'dot' representa el subconjunto de datos para el grupo actual
group_data <- .
# Llamar a las funciones auxiliares con los datos del grupo actual
Paridad_Alcalde_val <- calculate_parity_mayor(group_data)
Paridad_Nominal_val <- calculate_parity_nominal_indigenous(group_data, ELECTION_ID_NOMINAL_COUNCIL)
Paridad_Indigena_val <- calculate_parity_nominal_indigenous(group_data, ELECTION_ID_INDIGENOUS_COUNCIL)
Paridad_Lista_val <- calculate_parity_list(group_data)
# Devolver una tabla de una sola fila con los resultados para este grupo
tibble(
Paridad_Alcalde = Paridad_Alcalde_val,
Paridad_Nominal = Paridad_Nominal_val,
Paridad_Indigena = Paridad_Indigena_val,
Paridad_Lista = Paridad_Lista_val
)
}) %>%
ungroup() # Desagrupar el resultado final
# --- 4. Calcular el Índice de Paridad de Género (IPG) a Nivel Municipal ---
municipal_gpi <- municipal_parity_metrics %>%
rowwise() %>% # Necesario para aplicar mean por fila
mutate(GPI_Municipal = mean(c(Paridad_Alcalde, Paridad_Nominal, Paridad_Indigena, Paridad_Lista), na.rm = TRUE)) %>%
ungroup()
# --- 5. Calcular el Índice de Paridad de Género (IPG) a Nivel Estatal ---
state_gpi <- municipal_gpi %>%
group_by(cod_state, state_description) %>%
summarise(GPI_State = mean(GPI_Municipal, na.rm = TRUE), .groups = 'drop')
# --- 6. Mostrar Resultados ---
print("Índice de Paridad de Género a Nivel Municipal:")
print(municipal_gpi %>% select(cod_state, municipality_description, Paridad_Alcalde, Paridad_Nominal, Paridad_Indigena, Paridad_Lista, GPI_Municipal))
print("Índice de Paridad de Género a Nivel Estatal:")
print(state_gpi)
View(municipal_gpi)
View(state_gpi)
View(municipal_gpi)
View(municipal_parity_metrics)
municipal_parity_metrics <- municipal_parity_metrics %>%
rowwise() %>% # Esto permite realizar operaciones fila por fila
mutate(
Paridad_Concejo = mean(c(Paridad_Nominal, Paridad_Lista), na.rm = TRUE)
) %>%
ungroup() # Es importante desagrupar después de usar rowwise()
# Crea el scatterplot
scatterplot_paridad <- ggplot(municipal_parity_metrics, aes(x = Paridad_Alcalde, y = Paridad_Concejo)) +
geom_point(alpha = 0.7, color = "darkblue", size = 3) + # alpha para transparencia, color y tamaño de los puntos
labs(
title = "Relación entre Paridad de Alcaldía y Paridad de Concejo",
x = "Paridad de Alcalde(sa) (%)",
y = "Paridad de Concejo (%) (Nominal y Lista)",
subtitle = "Cada punto representa un municipio"
) +
theme_minimal() + # Un tema limpio para el gráfico
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
plot.subtitle = element_text(hjust = 0.5, size = 10, color = "gray50"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
) +
# Opcional: Establecer límites para los ejes si las paridades están en rango 0-100
xlim(0, 100) +
ylim(0, 100) +
# Opcional: Añadir una línea de 45 grados para visualizar la igualdad (y=x)
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red", alpha = 0.6)
# Muestra el scatterplot
print(scatterplot_paridad)
municipal_gpi <- municipal_parity_metrics %>%
rowwise() %>% # Necesario para aplicar mean por fila
mutate(GPI_Municipal_wo_Ind = mean(c(Paridad_Alcalde, Paridad_Nominal, Paridad_Lista), na.rm = TRUE)) %>%
ungroup()
state_gpi <- municipal_gpi %>%
group_by(cod_state, state_description) %>%
summarise(GPI_State_wo_Ind = mean(GPI_Municipal_wo_Ind, na.rm = TRUE), .groups = 'drop')

# Melt the data frame to long format
inflation_long <- inflation_data %>%
pivot_longer(cols = c(BCV, OVF), names_to = "Source", values_to = "Inflation_Rate")
# Adjust label positions and orientations
inflation_long <- inflation_long %>%
mutate(
angle = 45,
hjust = ifelse(Source == "OVF", 0, 1), # Adjust horizontal alignment
vjust = ifelse(Source == "OVF", -0.5, 1.5) # Adjust vertical alignment
)
# Determine a slightly wider y-axis limit based on the maximum OVF value
max_ovf <- max(inflation_long$Inflation_Rate[inflation_long$Source == "OVF"], na.rm = TRUE)
y_upper_limit <- 4 * max_ovf # Increase by 20%
# Create the inflation rate plot with log10 scale and point labels
ggplot(inflation_long, aes(x = Año, y = Inflation_Rate, color = Source)) +
geom_line(linewidth = 1) +
geom_point(size = 3) +
geom_text(aes(label = format(Inflation_Rate, big.mark = ",", scientific = FALSE),
angle = angle, hjust = hjust, vjust = vjust),
size = 3) +
scale_y_log10(labels = comma, limits = c(min(inflation_long$Inflation_Rate, na.rm = TRUE) / 1.5, y_upper_limit)) + # Set y-axis limits
scale_x_continuous(breaks = 2016:2024) +
scale_color_manual(values = c("BCV" = "red", "OVF" = "blue")) +
labs(
title = "Venezuela Annual Inflation Rate (BCV vs. OVF)",
subtitle = "Data from 2016 to 2024",
x = "Year",
y = "Annual Inflation Rate (Log Scale)",
color = "Source"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
plot.subtitle = element_text(hjust = 0.5, size = 12, color = "gray"),
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "top"
)
install.packages("devtools")
devtools::install_github("vdeminstitute/ERT")
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("vdeminstitute/ERT")
devtools::install_github("vdeminstitute/ERT")
library(ERT)
episodes <- get_eps()
plot_episodes(country = "Venezuela")
plot_episodes(country = "Spain")
plot_episodes(country = "Chile")
library(ERT)
plot_episodes(country = "Peru")
library(ERT)
plot_episodes(country = "Peru")
plot_episodes(country = "El Salvador")
library(ERT)
plot_episodes(country = "El Salvador")
plot_episodes()
plot_all()
r --version
R --version
versio(R)
version(R)
version()
R.version()
version
for (state_id in unique_states) {
state_data <- election_3_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Alcalde(sa) en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(stringr)
library(patchwork)
library(cowplot)
em2025 <- read.csv("dataset_em2025_candidatos.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE, encoding = "UTF-8")
em2025 <- em2025 %>%
mutate(state_description = gsub("EDO. ", "", state_description))
setwd("D:/Projects/gender-parity-eanr2025")
em2025 <- read.csv("dataset_em2025_candidatos.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE, encoding = "UTF-8")
# 1.1 Limpiar la columna state_description eliminando "EDO. "
em2025 <- em2025 %>%
mutate(state_description = gsub("EDO. ", "", state_description))
em2025 <- em2025 %>%
mutate(state_description = gsub("BOLIVARIANO DE ", "", state_description))
em2025 <- em2025 %>%
mutate(state_description = gsub("DISTRITO ", "DTTO ", state_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("MP. ", "", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("MP.", "", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("BOLIVARIANO ", "", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("AUTONOMO ", "", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("TURISTICO ", "", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("TENIENTE CORONEL", "TCNEL.", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("GENERAL EN JEFE", "GJ.", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("CAPITAN DE NAVIO", "CN.", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("GENERAL DE DIVISION", "GD.", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("ALMIRANTE", "A.", municipality_description))
em2025 <- em2025 %>%
mutate(municipality_description = gsub("CORONEL", "CNEL.", municipality_description))
# Filtrar por election_type_id = 16
election_3_data <- em2025 %>%
filter(election_type_id == 3)
unique_states <- unique(election_3_data$cod_state)
unique_states_desc <- unique(election_3_data$state_description)
# 3. Crear los boxplots
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_3_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Alcalde(sa) en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_3_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(cod_municipality, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(cod_municipality) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Alcalde(sa) en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
for (state_id in unique_states) {
state_data <- election_3_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Alcalde(sa) en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
#ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_3_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Alcalde(sa) en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
# Filtrar por election_type_id = 15
election_15_data <- em2025 %>%
filter(election_type_id == 15)
unique_states <- unique(election_15_data$cod_state)
unique_states_desc <- unique(election_15_data$state_description)
# 3. Crear los boxplots
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_15_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- election_15_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = "Porcentaje de Género por Estado y posición para la elección a Concejal(a) Nominal",
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
# Filtrar por election_type_id = 15
election_15_data <- em2025 %>%
filter(election_type_id == 15)
unique_states <- unique(election_15_data$cod_state)
unique_states_desc <- unique(election_15_data$state_description)
# 3. Crear los boxplots
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_15_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = "Porcentaje de Género por Estado y posición para la elección a Concejal(a) Nominal",
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
# Filtrar por election_type_id = 15
election_15_data <- em2025 %>%
filter(election_type_id == 15)
unique_states <- unique(election_15_data$cod_state)
unique_states_desc <- unique(election_15_data$state_description)
# 3. Crear los boxplots
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_15_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Concejal(a) Nominal en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_alcalde_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
for (state_id in unique_states) {
state_data <- election_15_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Concejal(a) Nominal en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_concejal_nom_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
# Filtrar por election_type_id = 17
election_17_data <- em2025 %>%
filter(election_type_id == 17)
unique_states <- unique(election_17_data$cod_state)
unique_states_desc <- unique(election_17_data$state_description)
# 3. Crear los boxplots
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_17_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Concejal(a) Indígena en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_concejal_ind_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
unique_states
unique_states_desc
# Filtrar por election_type_id = 17
election_17_data <- em2025 %>%
filter(election_type_id == 17)
unique_states <- unique(election_17_data$cod_state)
unique_states_desc <- unique(election_17_data$state_description)
# 3. Crear los boxplots
# Loop through each state to create a separate plot
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_17_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Concejal(a) Indígena en", str_to_title(tolower(unique_states_desc[state_id])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_concejal_ind_", unique_states_desc[state_id], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
unique_states_desc[which(unique_states == 23)]
# You can uncomment this loop if you want separate plots per state
for (state_id in unique_states) {
state_data <- election_17_data %>%
filter(cod_state == state_id)
# 3. Contar candidatos por estado, género y list_order
conteo_candidatos <- state_data %>%
group_by(municipality_description, gender, list_order) %>%
summarise(cantidad = n(), .groups = 'drop') %>%
group_by(municipality_description, list_order) %>%
mutate(porcentaje = cantidad / sum(cantidad) * 100) %>%
ungroup()
# 4. Preparar los datos para el gráfico (opcional, pero recomendado para ggplot2)
#  En este caso, los datos ya están en un formato adecuado para graficar barras apiladas o agrupadas.
plot_title <- paste("Distribución de candidatos a Concejal(a) Indígena en", str_to_title(tolower(unique_states_desc[which(unique_states == state_id)])))
# 5.  Crear el gráfico de barras
p <- ggplot(conteo_candidatos, aes(x = municipality_description, y = porcentaje, fill = gender)) +
geom_bar(stat = "identity", position = "stack") + # o "stack" para barras apiladas
facet_wrap(~list_order, labeller = labeller(list_order = c("1" = "Principal", "2" = "Suplente"))) +
scale_fill_manual(values = c("M" = "green", "F" = "orange")) +
labs(
title = plot_title,
x = "",
y = "Porcentaje",
fill = "Género"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p) # Print the plot to display it
# Optional: Save the plot to a file
ggsave(filename = paste0("fig_concejal_ind_", unique_states_desc[which(unique_states == state_id)], ".png"), plot = p, width = 10, height = 6, bg = "white")
}
